## Priorities

1. Lofting library
2. Visualization
3. UI

## Lofting Library

Build as a standalone library, with an API + data model that can be used by any frontend.

Stateful + serializable state, for synchronization.

### Thoughts

- Editing should be as non-destructive as possible. This requires thinking through the
  stored state/sketch mapping data structure.
- Stretch: provide tools to selectively modify the lofting algorithm's output.
- API options: some operations will require recomputing the loft, some will not.
  - Expose everthing via a flat, top-level API, so that we can handle recomputing. Larger top-level API,
    but easy to handle.
  - Expose sub-objects (like `Sketch`) and put some vars in a `Cell`, so that they can be modified via
    `&self` functions. Only recompute on `&mut self` functions. Cleaner, smaller API, but also more complex
    and potentially unintuitive.
- Lofting
  - Use radial error vs positional (xy) error, to account for sketches that may be scaled much larger
  - To determine number of edges, allow the user to specify. Otherwise, default to the number of vertices in the sketch with the most vertices

### Algorithm

#### Constraints

- Only sketches with increasing radial angle between vertices allowed (i.e. a line drawn from the center of the sketch outwards
  will only intersect the boundary once).
- Rotation is applied before lofting, position is not.

#### Overview

1. Sort all vertex-vertex connections by radial error.
2. Take edge with least error.
3. Repeat 1-2 until all valid vertex-vertex connections have been formed, taking max radial edge angle into account.
4. Create sections from formed faces (potentially n-gons).
5. Finalize sections. For each unconnected vertex in each section, create an intermediate vertex on opposite sketch edge with radial angle of 0.

## Dependencies

- *glam:* linear algebra.

## Progress Log

Start with loft lib API sketch.
Think about the data model/how to persist state across edits.
Think about algorithm and parameters/tuning.
